= Unbabelプロトコル仕様

== 概要

Unbabelではホスト言語のスクリプトにゲスト言語のスクリプトを文字列
として埋め込み、それをゲスト言語のインタプリタに食わせることで
計算を行います。

埋め込むスクリプトには以下のような制約があります。

* 1つの関数定義であること。
* シグネチャを書いてあること。

例えば以下のようになります。

    ;; fib :: Int -> Int
    (define (fib x)
      (case x
        ((0) 0)
        ((1) 1)
        (else (+ (fib (- x 2)) (fib (- x 1))))))

上のコードはSchemeのプログラムで、fibという名前の関数1つが定義
されています。またコメントで fib :: Int -> Int (つまりfibは
Intを一つ引数に取り、Intを返す関数) のように指定しています。
シグネチャの書式はHaskellといっしょです。即ち:

  関数名 :: 引数1の型 -> 引数2の型 -> 引数3の型 -> 戻り値の型

サポートしている型は

* Int (数値)
* String (文字列)
* [Int], [[Int]], [[[Int]]]... 
  (数値のリスト, 数値のリストのリスト、...)
* [String], [[String]], [[[String]]]...
  (文字列のリスト, 文字列のリストのリスト、...)

です。文字列に2バイト文字を使うときのエンコーディングはUTF-8
のみとします。

== 実行の仕組み
Unbabelでは埋め込まれたコードに(Cでいう)main関数の部分を付け加えて
テンポラリスクリプトを作り、パイプを使ってインタプリタに渡すことで
計算を行います。

例えば
  require 'unbabel'

  fib = Unbabel::Scheme.new(<<-EOD)
    ;; fib :: Int -> Int
    (define (fib x)
      (case x
        ((0) 0)
        ((1) 1)
        (else (+ (fib (- x 2)) (fib (- x 1))))))
  EOD
  p fib[10]  #=> 55

という感じでRubyからSchemeの関数を呼ぶとき、

  require 'unbabel'
  <中略>
  p fib[10]  #=> 55

  (define (main args)   ; ここが
    (write (fib 10)))   ; 追加された部分

のようなテンポラリスクリプトが生成されます。

== プロトコル

=== ゲスト言語に値を渡す方法

ホスト言語(のライブラリ)は、渡したい引数を「ゲスト言語の書式で」
テンポラリスクリプトに埋め込むことでゲスト言語に値を渡します。

例えば "foo" という文字列と [1,2,3] というリストをSchemeプログラム
に渡したい場合は、

  "foo" '(1 2 3)

のような表現を言語定義ファイルの<ARGUMENTS>のところに埋め込みます。

言語によってリストリテラルの書式が違うので、言語定義ファイルのargtype
プロパティで書式を指定しています。

例:
  [argtype]  [表現]
  -------------------
  square     [1, 2, 3]
  paren      (1, 2, 3)
  sexp       '(1 2 3)

=== ゲスト言語から値を返す方法

ゲスト言語(のmain部分)は、結果をS式文字列で出力します。ライブラリ側で
これをデコードします。

例:
  [データ]               [S式表現]
  ------------------------------------------
  1                   => 1
  "aa"                => "aa"
  [1, 2]              => (1 2)
  "a" "b" "c"         => ("a" "b" "c")
  [[1, 2], [3, 4, 5]] => ((1 2) (3 4 5))

== 言語定義ファイル

以下は言語定義ファイルの例です。

templates/ruby.unb:

  name:Ruby
  comment:#
  command:ruby
  argtype:square
  stub:
  <FUNCTION_DEFINITION>

  class Babel
    def self.to_sexp(x)
      case x
      when Numeric
        x.to_s
      when String
        x.inspect
      when Array
        '(' + x.map{|item| Babel.to_sexp(item)}.join(' ') + ')'
      else
        raise
      end
    end
  end
  print Babel.to_sexp(<FUNCTION_NAME>(<ARGUMENTS>))

最初の方にプロパティ定義があります。プロパティ名と値が「:」で
区切られています。パーズを簡単にするため、「:」の前後や行末に
余計な空白を入れてはいけません。

"stub:\n" という行以降はテンポラリスクリプトのテンプレートになり
ます。<FUNCTION_DEFINITION>にゲスト言語のスクリプトが、
<FUNCTION_NAME> に関数名が、<ARGUMENTS>にゲスト言語の書式に合わせた
引数の表現が埋め込まれます。

=== ファイル名

拡張子は*.unbです。ファイル名はunder_scoredのように全て小文字かつ
アンダースコアで区切ります。(実装によってはファイル名がホスト言語
での識別子になります)

=== name

言語名です。UpperCamelCaseのように大文字から始まり、アルファベット・
数字・アンダースコアが並ぶ文字列とします。

=== command

インタプリタの実行コマンド名です。

=== argtype

引数の埋め込み形式です(前述)。

== 実装方法

=== 言語定義ファイル側

オブジェクトをS式表現の文字列にダンプするコードを書けばおk。
単体で実行されるので、Unbabelライブラリで定義した関数とかは一切
使えないことに注意。(いやもちろんrequireなどすれば使えますが、
ゲストとして使いたいだけのときにもホスト用ライブラリのインストールが
必要になるので、非推奨とします)

=== ライブラリ側

Unbabelの呼び出し側になる言語は、(Rubyのpopen3のように)外部プロセスを
起動してその標準入力／標準出力にアクセスする手段が用意されてなくては
いけません(まぁ最低限system関数があれば、/tmpにテンポラリスクリプトを
作ることでなんとかなりますが)。

必要な機能は以下です。

* 言語定義ファイルを読み込む
* シグネチャを見つけてパーズする
* 渡された引数をゲスト言語の書式にフォーマットする
* テンポラリスクリプトを作る
* インタプリタを起動し、標準入力にテンポラリスクリプトをwriteする
* インタプリタの標準出力をreadし、S式形式の文字列をデコードする

